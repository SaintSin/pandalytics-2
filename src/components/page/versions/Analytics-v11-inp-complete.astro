---
// ANALYTICS VERSION 11 - INP IMPLEMENTATION COMPLETE
// Date: 250906 17:35
// Status: ‚úÖ PRODUCTION READY - Complete Core Web Vitals 2024-2025 implementation
// Key Changes from V10:
// - Added missing INP (Interaction to Next Paint) measurement
// - Added Performance Observer for "event" type with buffered mode
// - INP calculation using interactionId, processingEnd, startTime
// - Added INP to metrics object initialization (inp: null)
// - Added INP to debug logging and error checking
// - Added "event" to Performance Observer support detection
// Issues Fixed:
// - ‚úÖ INP was completely missing from Analytics component (causing null values)
// - ‚úÖ Now captures worst interaction delay during page session
// - ‚úÖ Proper INP measurement for user interactions (clicks, taps, key presses)
// Current Status:
// - ‚úÖ All 3 official Core Web Vitals 2024-2025: LCP, INP, CLS
// - ‚úÖ Important supplementary metrics: FCP, TTFB
// - ‚ö†Ô∏è Legacy FID retained for historical comparison (deprecated March 2024)
// Note: Google replaced FID with INP in March 2024 as official Core Web Vital
//       FID only measured first interaction delay, INP measures all interactions

const siteId = Astro.site ? new URL(Astro.site).hostname : "localhost";
---

<script define:vars={{ siteId }} is:inline>
	(function () {
		// Debug toggle - set to false for production
		const DEBUG = false;

		const log = (...args) => DEBUG && console.log(...args);
		const warn = (...args) => DEBUG && console.warn(...args);
		const error = (...args) => DEBUG && console.error(...args);

		log("üöÄ Astro-only Analytics loaded");

		if (
			location.hostname === "localhost" ||
			location.hostname === "127.0.0.1"
		) {
			log("üöß Disabled in development");
			return;
		}

		function trackPageCWV() {
			// Simple session management - one per browser session
			let sessionId = sessionStorage.getItem("astro_cwv_session");
			if (!sessionId) {
				sessionId =
					"cwv_" +
					Date.now() +
					"_" +
					Math.random().toString(36).substring(2, 11);
				sessionStorage.setItem("astro_cwv_session", sessionId);
				log("üÜï New session:", sessionId);
			}

			const currentPath = location.pathname;

			// Per-page time-based deduplication (60 seconds)
			const now = Date.now();
			const lastSentKey = `cwv_sent_${currentPath}`;
			const lastSent = parseInt(sessionStorage.getItem(lastSentKey) || "0");
			const timeSinceLastSent = now - lastSent;
			const cooldown = 60000; // 60s

			if (timeSinceLastSent < cooldown) {
				log(
					`‚è≠Ô∏è Skip ${currentPath} - sent ${Math.round(timeSinceLastSent / 1000)}s ago`,
				);
				return;
			}

			// Browser detection
			const parseBrowser = (ua) => {
				if (!ua) return "Unknown";
				const lower = ua.toLowerCase();
				if (lower.includes("safari/") && !lower.includes("chrome")) {
					const version = ua.match(/version\/(\d+)/i);
					return `Safari ${version ? version[1] : ""}`;
				} else if (lower.includes("chrome/") && !lower.includes("edg")) {
					const version = ua.match(/chrome\/(\d+)/i);
					return `Chrome ${version ? version[1] : ""}`;
				} else if (lower.includes("firefox/")) {
					const version = ua.match(/firefox\/(\d+)/i);
					return `Firefox ${version ? version[1] : ""}`;
				}
				return "Other";
			};

			const browser = parseBrowser(navigator.userAgent);
			log("üîç Browser:", browser, "| Path:", currentPath);

			const metrics = {
				session_id: sessionId,
				site_id: siteId,
				url: location.href,
				path: currentPath,
				user_agent: navigator.userAgent,
				browser: browser,
				screen_width: window.screen.width,
				screen_height: window.screen.height,
				lcp: null,
				fid: null,
				cls: 0,
				fcp: null,
				ttfb: null,
				inp: null,
			};

			const captureStart = performance.now();
			log("üìä Starting fresh CWV capture at:", captureStart);

			// TTFB - only meaningful for actual navigation, not view transitions
			const navEntry = performance.getEntriesByType("navigation")[0];
			if (navEntry && navEntry.responseStart) {
				metrics.ttfb = navEntry.responseStart;
				log("‚úÖ TTFB:", metrics.ttfb);
			}

			// For Astro view transitions, always use buffered observers
			// View transitions don't trigger new paint events, so we capture the current page's metrics
			log("üéØ Using buffered observers (Astro view transitions)");

			// Check Performance Observer support
			const supportedTypes = [];
			const testTypes = [
				"largest-contentful-paint",
				"layout-shift",
				"first-input",
				"paint",
				"event",
			];
			testTypes.forEach((type) => {
				try {
					PerformanceObserver.supportedEntryTypes.includes(type) &&
						supportedTypes.push(type);
				} catch (e) {}
			});
			log("üîß Supported Performance Observer types:", supportedTypes);

			// LCP - always buffered for Astro
			log("üîß Registering LCP observer...");
			try {
				new PerformanceObserver((list) => {
					const entries = list.getEntries();
					log("üîç LCP Observer fired - entries:", entries.length);

					if (entries.length > 0) {
						log(
							"üìä LCP entries:",
							entries.map((e) => ({
								renderTime: e.renderTime,
								loadTime: e.loadTime,
								startTime: e.startTime,
								element: e.element?.tagName || "unknown",
							})),
						);
					} else {
						warn("‚ö†Ô∏è LCP Observer fired but no entries found");
					}

					const lastEntry = entries.pop();
					if (lastEntry) {
						metrics.lcp =
							lastEntry.renderTime || lastEntry.loadTime || lastEntry.startTime;
						log("‚úÖ LCP set to:", metrics.lcp);
					} else {
						warn("‚ùå No LCP entry to process");
					}
				}).observe({ type: "largest-contentful-paint", buffered: true });
				log("‚úÖ LCP observer registered");
			} catch (error) {
				error("‚ùå LCP observer failed:", error.message);
			}

			// FCP - always buffered for Astro
			new PerformanceObserver((list) => {
				for (const entry of list.getEntries()) {
					if (entry.name === "first-contentful-paint") {
						metrics.fcp = entry.startTime;
						log("‚úÖ FCP:", metrics.fcp);
					}
				}
			}).observe({ type: "paint", buffered: true });

			// CLS - use buffered for cumulative score
			log("üîß Registering CLS observer...");
			new PerformanceObserver((list) => {
				const entries = list.getEntries();
				log("üîç CLS Observer fired - entries:", entries.length);

				for (const entry of entries) {
					if (!entry.hadRecentInput && entry.value !== undefined) {
						metrics.cls += entry.value;
						log("‚úÖ CLS delta:", entry.value, "| Total:", metrics.cls);
					}
				}

				if (entries.length === 0) {
					log("‚úÖ CLS: No layout shifts detected (good performance!)");
				}
			}).observe({ type: "layout-shift", buffered: true });
			log("‚úÖ CLS observer registered");

			// FID - use buffered for any recorded input delay (DEPRECATED March 2024)
			log("üîß Registering FID observer...");
			new PerformanceObserver((list) => {
				const entries = list.getEntries();
				log("üîç FID Observer fired - entries:", entries.length);

				const firstInput = entries[0];
				if (firstInput && firstInput.processingStart) {
					metrics.fid = firstInput.processingStart - firstInput.startTime;
					log("‚úÖ FID:", metrics.fid, "ms");
				} else if (entries.length === 0) {
					log("‚úÖ FID: No input delay recorded (good performance!)");
				} else {
					log("‚ö†Ô∏è FID entry exists but no processingStart:", firstInput);
				}
			}).observe({ type: "first-input", buffered: true });
			log("‚úÖ FID observer registered");

			// INP - Interaction to Next Paint (NEW Core Web Vital as of March 2024)
			log("üîß Registering INP observer...");
			try {
				new PerformanceObserver((list) => {
					const entries = list.getEntries();
					log("üîç INP Observer fired - entries:", entries.length);

					let maxDelay = 0;
					for (const entry of entries) {
						if (entry.interactionId && entry.processingEnd && entry.startTime) {
							const delay = entry.processingEnd - entry.startTime;
							maxDelay = Math.max(maxDelay, delay);
							log("üìä INP interaction:", {
								type: entry.name,
								delay: delay,
								interactionId: entry.interactionId,
							});
						}
					}

					if (maxDelay > 0) {
						metrics.inp = maxDelay;
						log("‚úÖ INP set to:", metrics.inp, "ms");
					} else if (entries.length === 0) {
						log("‚úÖ INP: No interactions recorded");
					}
				}).observe({ type: "event", buffered: true });
				log("‚úÖ INP observer registered");
			} catch (error) {
				error("‚ùå INP observer failed:", error.message);
			}

			// Send after delay to capture metrics
			setTimeout(() => {
				log("üì§ Sending:", {
					session: metrics.session_id,
					path: metrics.path,
					browser: metrics.browser,
					lcp: metrics.lcp,
					fcp: metrics.fcp,
					cls: metrics.cls,
					fid: metrics.fid,
					ttfb: metrics.ttfb,
					inp: metrics.inp,
				});

				// Debug: Log if all CWV are null
				if (
					!metrics.lcp &&
					!metrics.fcp &&
					!metrics.fid &&
					!metrics.inp &&
					metrics.cls === 0
				) {
					warn("üö® No CWV captured - all values null/zero");
				}

				const blob = new Blob([JSON.stringify(metrics)], {
					type: "application/json",
				});

				if (navigator.sendBeacon) {
					navigator.sendBeacon("/.netlify/functions/pandalytics", blob);
					log("üì° Sent via beacon");
				} else {
					fetch("/.netlify/functions/pandalytics", {
						method: "POST",
						body: JSON.stringify(metrics),
						headers: { "Content-Type": "application/json" },
						keepalive: true,
					}).catch(() => {});
					log("üì° Sent via fetch");
				}

				// Mark as sent
				sessionStorage.setItem(lastSentKey, now.toString());
				log("‚úÖ Marked sent:", new Date().toLocaleTimeString());
			}, 1500);
		}

		// ONLY listen to astro:page-load (fires for all Astro navigation)
		document.addEventListener("astro:page-load", () => {
			log("üéØ astro:page-load fired");
			trackPageCWV();
		});

		log("‚úÖ Astro Analytics ready");
	})();
</script>
