---
// ANALYTICS VERSION 9 - ALWAYS BUFFERED FOR ASTRO
// Date: 250906 16:52
// Status: TESTING - Always use buffered observers for Astro view transitions
// Key Discovery: Astro view transitions don't trigger new Performance Observer events
// Safari TP logs showed all CWV as null with non-buffered observers
// Changes from V8:
// - Removed first page vs subsequent page detection
// - Always use buffered observers for ALL metrics (LCP, FCP, CLS, FID)
// - Simplified logging
// Issues Fixed:
// - ‚úÖ Should capture real CWV data now (LCP, FCP, etc.)
// - ‚úÖ Browser detection working ("Safari 26")  
// - ‚úÖ TTFB captured (456ms)
// Remaining Challenge:
// - ‚ùå Will likely return to identical CWV values across pages
// - This is fundamental to Astro view transitions - they don't create new performance entries
// Theory: For Astro sites, view transitions show same CWV as initial page load
//         This might be correct behavior since DOM updates without full navigation

const siteId = Astro.site ? new URL(Astro.site).hostname : "localhost";
---

<script define:vars={{ siteId }} is:inline>
  (function () {
    console.log("üöÄ Astro-only Analytics loaded");
    
    if (location.hostname === "localhost" || location.hostname === "127.0.0.1") {
      console.log("üöß Disabled in development");
      return;
    }

    function trackPageCWV() {
      // Simple session management - one per browser session
      let sessionId = sessionStorage.getItem("astro_cwv_session");
      if (!sessionId) {
        sessionId = 'cwv_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
        sessionStorage.setItem("astro_cwv_session", sessionId);
        console.log("üÜï New session:", sessionId);
      }

      const currentPath = location.pathname;
      
      // Per-page time-based deduplication (60 seconds)
      const now = Date.now();
      const lastSentKey = `cwv_sent_${currentPath}`;
      const lastSent = parseInt(sessionStorage.getItem(lastSentKey) || "0");
      const timeSinceLastSent = now - lastSent;
      const cooldown = 60000; // 60s
      
      if (timeSinceLastSent < cooldown) {
        console.log(`‚è≠Ô∏è Skip ${currentPath} - sent ${Math.round(timeSinceLastSent/1000)}s ago`);
        return;
      }

      // Browser detection
      const parseBrowser = (ua) => {
        if (!ua) return "Unknown";
        const lower = ua.toLowerCase();
        if (lower.includes("safari/") && !lower.includes("chrome")) {
          const version = ua.match(/version\/(\d+)/i);
          return `Safari ${version ? version[1] : ""}`;
        } else if (lower.includes("chrome/") && !lower.includes("edg")) {
          const version = ua.match(/chrome\/(\d+)/i);
          return `Chrome ${version ? version[1] : ""}`;
        } else if (lower.includes("firefox/")) {
          const version = ua.match(/firefox\/(\d+)/i);
          return `Firefox ${version ? version[1] : ""}`;
        }
        return "Other";
      };

      const browser = parseBrowser(navigator.userAgent);
      console.log("üîç Browser:", browser, "| Path:", currentPath);

      const metrics = {
        session_id: sessionId,
        site_id: siteId,
        url: location.href,
        path: currentPath,
        user_agent: navigator.userAgent,
        browser: browser,
        screen_width: window.screen.width,
        screen_height: window.screen.height,
        lcp: null,
        fid: null,
        cls: 0,
        fcp: null,
        ttfb: null,
      };

      const captureStart = performance.now();
      console.log("üìä Starting fresh CWV capture at:", captureStart);
      
      // TTFB - only meaningful for actual navigation, not view transitions
      const navEntry = performance.getEntriesByType("navigation")[0];
      if (navEntry && navEntry.responseStart) {
        metrics.ttfb = navEntry.responseStart;
        console.log("‚úÖ TTFB:", metrics.ttfb);
      }

      // For Astro view transitions, always use buffered observers
      // View transitions don't trigger new paint events, so we capture the current page's metrics
      console.log("üéØ Using buffered observers (Astro view transitions)");
      
      // LCP - always buffered for Astro
      new PerformanceObserver((list) => {
        const lastEntry = list.getEntries().pop();
        if (lastEntry) {
          metrics.lcp = lastEntry.renderTime || lastEntry.loadTime || lastEntry.startTime;
          console.log("‚úÖ LCP:", metrics.lcp);
        }
      }).observe({ type: "largest-contentful-paint", buffered: true });

      // FCP - always buffered for Astro
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.name === "first-contentful-paint") {
            metrics.fcp = entry.startTime;
            console.log("‚úÖ FCP:", metrics.fcp);
          }
        }
      }).observe({ type: "paint", buffered: true });

      // CLS - use buffered for cumulative score
      new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (!entry.hadRecentInput && entry.value !== undefined) {
            metrics.cls += entry.value;
            console.log("‚úÖ CLS delta:", entry.value, "| Total:", metrics.cls);
          }
        }
      }).observe({ type: "layout-shift", buffered: true });

      // FID - use buffered for any recorded input delay
      new PerformanceObserver((list) => {
        const firstInput = list.getEntries()[0];
        if (firstInput && firstInput.processingStart) {
          metrics.fid = firstInput.processingStart - firstInput.startTime;
          console.log("‚úÖ FID:", metrics.fid);
        }
      }).observe({ type: "first-input", buffered: true });

      // Send after delay to capture metrics
      setTimeout(() => {
        console.log("üì§ Sending:", {
          session: metrics.session_id,
          path: metrics.path,
          browser: metrics.browser,
          lcp: metrics.lcp,
          fcp: metrics.fcp,
          cls: metrics.cls,
          fid: metrics.fid,
          ttfb: metrics.ttfb
        });
        
        // Debug: Log if all CWV are null
        if (!metrics.lcp && !metrics.fcp && !metrics.fid && metrics.cls === 0) {
          console.warn("üö® No CWV captured - all values null/zero");
        }

        const blob = new Blob([JSON.stringify(metrics)], { type: "application/json" });
        
        if (navigator.sendBeacon) {
          navigator.sendBeacon("/.netlify/functions/pandalytics", blob);
          console.log("üì° Sent via beacon");
        } else {
          fetch("/.netlify/functions/pandalytics", {
            method: "POST",
            body: JSON.stringify(metrics),
            headers: { "Content-Type": "application/json" },
            keepalive: true,
          }).catch(() => {});
          console.log("üì° Sent via fetch");
        }

        // Mark as sent
        sessionStorage.setItem(lastSentKey, now.toString());
        console.log("‚úÖ Marked sent:", new Date().toLocaleTimeString());
      }, 1500);
    }

    // ONLY listen to astro:page-load (fires for all Astro navigation)
    document.addEventListener("astro:page-load", () => {
      console.log("üéØ astro:page-load fired");
      trackPageCWV();
    });
    
    console.log("‚úÖ Astro Analytics ready");
  })();
</script>