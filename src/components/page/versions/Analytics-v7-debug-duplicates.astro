---
// ANALYTICS VERSION 7 - DEBUG DUPLICATE VALUES
// Date: 250906 15:55
// Status: DEBUGGING - Added extensive logging to identify why identical CWV values persist
// Problem: Sessions cwv_1757172751614_acnt5dhoh and cwv_1757172735591_enmcx9jod show identical values
// Theory: Multiple sessions being created, each thinking it's "initial load"
// Debug additions:
// - Log session creation vs reuse
// - Log isInitialLoad logic detailed breakdown
// - Log Performance Observer callbacks with timestamps
// - Log exactly what CWV values are captured and when

const siteId = Astro.site ? new URL(Astro.site).hostname : "localhost";
---

<script define:vars={{ siteId }} is:inline>
  (function () {
    console.log("üöÄ DEBUG Analytics loaded, hostname:", location.hostname);

    if (
      location.hostname === "localhost" ||
      location.hostname === "127.0.0.1"
    ) {
      console.log("üöß CWV tracking disabled in development");
      return;
    }

    function trackCoreWebVitals() {
      // DEBUG: Log session storage state
      console.log("üìã Session storage state:", {
        existing_session: sessionStorage.getItem("cwv_session"),
        cwv_initialized: sessionStorage.getItem("cwv_initialized"),
        cwv_last_path: sessionStorage.getItem("cwv_last_path"),
      });

      let sessionId = sessionStorage.getItem("cwv_session");
      if (!sessionId) {
        sessionId =
          "cwv_" +
          Date.now() +
          "_" +
          Math.random().toString(36).substring(2, 11);
        sessionStorage.setItem("cwv_session", sessionId);
        console.log("üÜï Created NEW session:", sessionId);
      } else {
        console.log("‚ôªÔ∏è  Using EXISTING session:", sessionId);
      }

      const isInitialLoad = !sessionStorage.getItem("cwv_initialized");
      const currentPath = location.pathname;

      console.log("üîç Load type analysis:", {
        isInitialLoad,
        currentPath,
        reason: isInitialLoad
          ? "No cwv_initialized flag"
          : "cwv_initialized exists",
      });

      // Time-based deduplication
      const now = Date.now();
      const lastSentKey = `cwv_last_sent_${currentPath}`;
      const lastSent = parseInt(sessionStorage.getItem(lastSentKey) || "0");
      const timeSinceLastSent = now - lastSent;
      const cooldownPeriod = 60 * 1000;

      console.log("‚è∞ Time deduplication check:", {
        currentPath,
        lastSent: new Date(lastSent).toLocaleTimeString(),
        timeSinceLastSent: Math.round(timeSinceLastSent / 1000) + "s",
        cooldownPeriod: cooldownPeriod / 1000 + "s",
        shouldSkip: timeSinceLastSent < cooldownPeriod,
      });

      if (timeSinceLastSent < cooldownPeriod) {
        console.log(`‚è≠Ô∏è  SKIPPING - cooldown active`);
        return;
      }

      sessionStorage.setItem("cwv_initialized", "true");
      sessionStorage.setItem("cwv_last_path", currentPath);

      const parseBrowser = (userAgent) => {
        if (!userAgent) return "Unknown";
        const ua = userAgent.toLowerCase();
        if (ua.includes("safari/") && !ua.includes("chrome")) {
          const version = userAgent.match(/version\/(\d+)/i);
          return `Safari ${version ? version[1] : ""}`;
        }
        return "Other";
      };

      const browser = parseBrowser(navigator.userAgent);
      console.log("üîç Browser detected:", browser);

      const metrics = {
        session_id: sessionId,
        site_id: siteId,
        url: location.href,
        path: location.pathname,
        user_agent: navigator.userAgent,
        browser: browser,
        screen_width: window.screen.width,
        screen_height: window.screen.height,
        lcp: null,
        fid: null,
        cls: 0,
        fcp: null,
        ttfb: null,
      };

      console.log(
        "üìä Starting CWV capture, strategy:",
        isInitialLoad ? "BUFFERED (initial load)" : "NON-BUFFERED (SPA nav)",
      );

      if (isInitialLoad) {
        console.log("üéØ INITIAL LOAD: Using buffered observers");

        // LCP with debugging
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries.pop();
          console.log("üìà LCP Observer fired:", {
            entryCount: entries.length + 1,
            lastEntry: lastEntry
              ? {
                  renderTime: lastEntry.renderTime,
                  loadTime: lastEntry.loadTime,
                  startTime: lastEntry.startTime,
                  final:
                    lastEntry.renderTime ||
                    lastEntry.loadTime ||
                    lastEntry.startTime,
                }
              : null,
          });
          if (lastEntry) {
            metrics.lcp =
              lastEntry.renderTime || lastEntry.loadTime || lastEntry.startTime;
            console.log("‚úÖ LCP set to:", metrics.lcp);
          }
        }).observe({ type: "largest-contentful-paint", buffered: true });

        // FCP with debugging
        new PerformanceObserver((list) => {
          const entries = list.getEntries();
          console.log("üé® FCP Observer fired:", {
            entryCount: entries.length,
            entries: entries.map((e) => ({
              name: e.name,
              startTime: e.startTime,
            })),
          });
          for (const entry of entries) {
            if (entry.name === "first-contentful-paint") {
              metrics.fcp = entry.startTime;
              console.log("‚úÖ FCP set to:", metrics.fcp);
            }
          }
        }).observe({ type: "paint", buffered: true });
      } else {
        console.log("üîÑ SPA NAVIGATION: Using non-buffered observers");
        const navigationStart = performance.now();
        console.log("‚è±Ô∏è  Navigation start timestamp:", navigationStart);

        // Non-buffered observers with timestamp filtering
        new PerformanceObserver((list) => {
          const allEntries = list.getEntries();
          const filteredEntries = allEntries.filter(
            (entry) => entry.startTime > navigationStart,
          );
          console.log("üìà SPA LCP Observer:", {
            total: allEntries.length,
            filtered: filteredEntries.length,
            navigationStart,
          });
          const lastEntry = filteredEntries.pop();
          if (lastEntry) {
            metrics.lcp =
              lastEntry.renderTime || lastEntry.loadTime || lastEntry.startTime;
            console.log("‚úÖ SPA LCP set to:", metrics.lcp);
          }
        }).observe({ type: "largest-contentful-paint", buffered: false });
      }

      setTimeout(() => {
        console.log("üì§ FINAL METRICS before send:", {
          session_id: metrics.session_id,
          path: metrics.path,
          browser: metrics.browser,
          lcp: metrics.lcp,
          fcp: metrics.fcp,
          timestamp: new Date().toLocaleTimeString(),
        });

        const blob = new Blob([JSON.stringify(metrics)], {
          type: "application/json",
        });

        console.log(
          `üì° SENDING CWV for ${metrics.path} (session: ${metrics.session_id})`,
        );

        if (navigator.sendBeacon) {
          navigator.sendBeacon("/.netlify/functions/pandalytics", blob);
        }

        sessionStorage.setItem(lastSentKey, Date.now().toString());
        console.log(
          "‚úÖ Marked as sent with timestamp:",
          new Date().toLocaleTimeString(),
        );
      }, 2000); // Longer delay to ensure CWV capture
    }

    try {
      console.log("üéØ Tracking CWV on page load");
      trackCoreWebVitals();

      document.addEventListener("astro:page-load", () => {
        console.log("üîÑ astro:page-load event fired");
        trackCoreWebVitals();
      });

      console.log("‚úÖ Analytics setup complete");
    } catch (error) {
      console.error("‚ùå Analytics setup failed:", error);
    }
  })();
</script>
